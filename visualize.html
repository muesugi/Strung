<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Strung</title>
		<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<link href='https://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/visualize.css">
		<script type="text/javascript">
		
			function getWindowWidth() {
				return window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth||0;
			}
			function getWindowHeight() {
				return window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight||0;
			}	

			THREE.CylinderCurvedSurfaceGeometry = function(radius, height, startAngle, endAngle, horizontalSegments, verticalSegments) {
				//optional params
				startAngle = startAngle || Math.PI/2;
				endAngle = endAngle || Math.PI;
				horizontalSegments = horizontalSegments || 25;
				verticalSegments = verticalSegments || 25;
				//

			    var width = radius * 2 * Math.PI;
			    var plane = new THREE.PlaneGeometry(width, height, horizontalSegments, verticalSegments);
			    var index = 0;

			    for(var i=0; i<=verticalSegments; i++) {
			        for(var j=0; j<=horizontalSegments; j++) {
			            var angle = startAngle + (j/horizontalSegments)*(endAngle - startAngle);
			            plane.vertices[index].z = radius * Math.cos(angle);
			            plane.vertices[index].x = radius * Math.sin(angle);
			            index++;
			        }
			    }

			    return plane;
			}

		</script>

	</head>
	<body>
	
	<div class="header">
		<a id="site_name" href="index.html">STRUNG</a><!--127.5px-->

		<!--site_nav floats backward, this is in reverse order:-->
		<a class="site_nav" id="docs" href="documentation.html">Documentation</a> <!--150.797px-->
		<a class="site_nav" id="textify" href="textify.html">Textify</a><!--68.125px-->
		<a class="site_nav" id="visualize" href="visualize.html">Visualize</a><!--86.4844px-->
		<a class="site_nav" id="chartify" href="chartify.html">Chartify</a> <!--79.8438px-->
	</div>
		<script type="text/javascript">
			header_spacing();
			function header_spacing(){
				window_w = getWindowWidth();
				title_w = 127.5 + window_w*.1; //width + padding-left
				remaining_width = window_w - title_w - 150.797 - 68.125 - 86.4844 - 79.8438 - 3*window_w*.05;
				//results that: site_name has a padding_left of 10%, a padding_right of 10%, and
				// documentation has a padding_right of 5%
				$(".site_nav").css("padding-left", remaining_width/4);
			}
			//// Scene Setup //////
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			camera.position.z = 200;

			var renderer = new THREE.WebGLRenderer( { alpha: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);

			var cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
			cameraControls.target.set(0, 0, 0);
			var clock = new THREE.Clock();

			//// Three.js settings for all stitches //////
			//var yarn_geometry = new THREE.CylinderGeometry(.1, .1, 2, 20);
			var yarn_material0 = new THREE.MeshBasicMaterial( {color: "red"});
			var yarn_material1 = new THREE.MeshBasicMaterial( {color: "black"});
			var yarn_material2 = new THREE.MeshBasicMaterial( {color: "green"});
			var yarn_material3 = new THREE.MeshBasicMaterial( {color: "blue"});

			//scaling depends on yarn being used
			//as wpi gets larger, "zoom in" closer--> set yarn radius (in inches) to pixel ratio for simplicity
			//wraps-per-inch, a standard metric for yarn purchase and storage 
			var yarn_wpi = 5; // where a wrap is defined as the diameter; wrap = 2 * radius
			// yarn radius in inches is 1/(2*yarn_wpi)
			var pix_per_radius = 1; // equiv to yarn radius in pixels

			function inches_to_pixels(n_inches){
				return n_inches * yarn_wpi * 2 * pix_per_radius; 
			}
			function pixels_to_inches(n_pixels){
				return n_pixels * (1/pix_per_radius) * .5 * (1/yarn_wpi); 
			}

			var x_max = window.innerWidth/4/2; //2 for testing only
			var start_x = x_max;

			var start_y = 000;
			var start_z = 000;

			var xpos = start_x;
			var ypos = start_y;
			var zpos = start_z;
			var direction = 1; // implement this later

			// Smooth curve over this many points
			var numPoints = 100;

			// using "_" naming convention for all geometry funcs to 
			// differentiate custom functions and THREE.js builtins

			// Given a CatmullRomCurve3, creates a THREE.geometry  
			// that follows this curve, smoothed over n_points points.
			// Possible helper for all custom geometry functions.
			function path_geometry_from_curve(n_points, curve){
				new_geom = new THREE.Geometry();
				geom_points = curve.getPoints(n_points);

				for(var i = 0; i < n_points; i++){
				    new_geom.vertices.push(geom_points[i]);  
				}
				return new_geom;
			}

			// Makes a (starting) tail yarn end 
			// starting at (xpos, ypos, zpos)
			function tail_geometry(xpos, ypos, zpos){
				tail_length_inches = 2; 
				tail_length_pixels = inches_to_pixels(tail_length_inches); 

				//n_points = 100;

				tail_curve = new THREE.CatmullRomCurve3([
				   new THREE.Vector3(xpos, ypos, zpos),
				   new THREE.Vector3(xpos - (tail_length_pixels/2), ypos - (tail_length_pixels/5), zpos),
				   new THREE.Vector3(xpos - tail_length_pixels, ypos, zpos),
				]);

				return new THREE.TubeGeometry(tail_curve);
				//return geometry_from_curve(n_points, tail_curve);
			}

			function slip_geometry(xpos, ypos, zpos){
				var n_points = 100;

				slip_curve = new THREE.CatmullRomCurve3([
				
					//always include start point
					new THREE.Vector3(xpos, ypos, zpos), 
					// loop 1 (flat on yz plane)
					new THREE.Vector3(xpos-(2*pix_per_radius), ypos, 
				    	zpos),
					///////
				    new THREE.Vector3(xpos-(3*pix_per_radius), 
				    	ypos-(2*pix_per_radius), 
				    	zpos-(2*pix_per_radius)),
				    new THREE.Vector3(xpos-(2*pix_per_radius), 
				    	ypos-(1*pix_per_radius), 
				    	zpos-(3*pix_per_radius)),
				    new THREE.Vector3(xpos-(1*pix_per_radius), 
				    	ypos, 
				    	zpos-(3*pix_per_radius)),
				    new THREE.Vector3(xpos, ypos, 
				    	zpos+(1*pix_per_radius)),
				    new THREE.Vector3(xpos, 
				    	ypos-(1*pix_per_radius), 
				    	zpos+(2*pix_per_radius)),
				    new THREE.Vector3(xpos-(1*pix_per_radius), 
				    	ypos-(2*pix_per_radius), 
				    	zpos),

				    new THREE.Vector3(xpos-(3*pix_per_radius), 
				    	ypos-(1*pix_per_radius), 
				    	zpos-(2*pix_per_radius)),

				    //loop (laying flat on xz plane)
				    new THREE.Vector3(xpos-(9*pix_per_radius), ypos, 
				    	zpos-(4*pix_per_radius)),
				    new THREE.Vector3(xpos-(10*pix_per_radius), ypos-(1*pix_per_radius), 
				    	zpos-(1*pix_per_radius)),
				    new THREE.Vector3(xpos-(9*pix_per_radius), ypos-(1*pix_per_radius), 
				    	zpos+(1*pix_per_radius)),
				    new THREE.Vector3(xpos-(3*pix_per_radius), ypos-(1*pix_per_radius), 
				    	zpos+(1*pix_per_radius)),
				    new THREE.Vector3(xpos-(3*pix_per_radius), ypos-(1*pix_per_radius), 
				    	zpos+(1*pix_per_radius)),

				    new THREE.Vector3(xpos, ypos-(1*pix_per_radius), zpos+(1*pix_per_radius)),

				    //turnaround to start next stitch
				    new THREE.Vector3(xpos+(1*pix_per_radius),
				    	ypos-(2*pix_per_radius), 
				    	zpos+(1*pix_per_radius)),
				    new THREE.Vector3(xpos+(0*pix_per_radius),
				    	ypos-(3*pix_per_radius), 
				    	zpos+(1*pix_per_radius)),
				    new THREE.Vector3(xpos-(20*pix_per_radius),
				    	ypos-(3*pix_per_radius), 
				    	zpos)
				]);

				return new THREE.TubeGeometry(slip_curve);
				//return path_geometry_from_curve(n_points, slip_curve);
			}


			/// Testing specific function calls.

			// tail
			scene.add(new THREE.Line(
				tail_geometry(start_x, start_y, start_z), 
				yarn_material0));
			xpos = xpos - tail_length_pixels;
			// slip stitch
			scene.add(new THREE.Line(
				slip_geometry(xpos, ypos, zpos), 
				yarn_material1));

			function render() {
				var delta = clock.getDelta();
				requestAnimationFrame( render );
				cameraControls.update(delta);
				renderer.render( scene, camera );
			}
			render();

		</script>
	</body>
</html>
	
	