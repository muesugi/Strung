<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Strung</title>
		<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/math.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<link href='https://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/visualize.css">
		<script type="text/javascript">
			// define 
			function getWindowWidth() {
				return window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth||0;
			}
			function getWindowHeight() {
				return window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight||0;
			}	
			var mm_per_inch = 25.4;
		</script>

	</head>
	<body>
	
	<div class="header">
		<a id="site_name" href="index.html">STRUNG</a><!--127.5px-->

		<!--site_nav floats backward, this is in reverse order:-->
		<a class="site_nav" id="docs" href="documentation.html">Documentation</a> <!--150.797px-->
		<a class="site_nav" id="textify" href="textify.html">Textify</a><!--68.125px-->
		<a class="site_nav" id="visualize" href="visualize.html">Visualize</a><!--86.4844px-->
		<a class="site_nav" id="chartify" href="chartify.html">Chartify</a> <!--79.8438px-->
	</div>

	<textarea id="textarea" spellcheck=false placeholder="chain(15); turn(); single(10); turn(); double(10); turn();">chain(10); turn(); single(1)</textarea>
	
		<script type="text/javascript">
			header_spacing();
			function header_spacing(){
				window_w = getWindowWidth();
				title_w = 127.5 + window_w*.1; //width + padding-left
				remaining_width = window_w - title_w - 150.797 - 68.125 - 86.4844 - 79.8438 - 3*window_w*.05;
				//results that: site_name has a padding_left of 10%, a padding_right of 10%, and
				// documentation has a padding_right of 5%
				$(".site_nav").css("padding-left", remaining_width/4);
			}

			//// SCENE SETUP //////
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			camera.position.z = 200;

			var renderer = new THREE.WebGLRenderer( { alpha: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);

			var x_max = window.innerWidth/4/2; //2 for testing only
			var start_x = x_max; // start_x, start_y, and start_z used for global start
			var start_y = 000; // startx, starty, startz used for some local start values
			var start_z = 000;

			var x = start_x; // x, y, z used for global position
			var y = start_y; //xpos, ypos, zpos used for local positioning
			var z = start_z; // should be in the same world though, just for differentiation.
			function set_global_coords(xpos, ypos, zpos){
				x = xpos;
				y = ypos;
				z = zpos;
			}

			var direction = -1; //always x direction, since y and z should *not* change

			var cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
			cameraControls.target.set(0, 0, 0);
			var clock = new THREE.Clock();
			var axisHelper = new THREE.AxisHelper( 50);
			scene.add( axisHelper );

			//// Three.js settings for all stitches //////
			//var yarn_geometry = new THREE.CylinderGeometry(.1, .1, 2, 20);
			var yarn_material0 = new THREE.MeshBasicMaterial( {color: "red"});
			var yarn_material1 = new THREE.MeshBasicMaterial( {color: "black"});
			var yarn_material2 = new THREE.MeshBasicMaterial( {color: "green"});
			var yarn_material3 = new THREE.MeshBasicMaterial( {color: "maroon"});
			var default_yarn = yarn_material3;
			var selected_yarn = default_yarn;

			//scaling depends on yarn being used
			//as wpi gets larger, "zoom in" closer--> set yarn radius (in inches) to pixel ratio for simplicity
			//wraps-per-inch, a standard metric for yarn purchase and storage 
			var yarn_wpi = 5; // where a wrap is defined as the diameter; wrap = 2 * radius
			// yarn radius in inches is 1/(2*yarn_wpi)
			var pix_per_radius = 1; // equiv to yarn radius in pixels

			function inches_to_pixels(n_inches){
				return n_inches * yarn_wpi * 2 * pix_per_radius; 
			}
			function pixels_to_inches(n_pixels){
				return n_pixels * (1/pix_per_radius) * .5 * (1/yarn_wpi); 
			}


			tail_length_inches = 2; 
			var tail_length_pixels = inches_to_pixels(tail_length_inches); 

			hook_diam_mm = 11.5; //standard hook sizing is hook diameter in mm
			hook_r_inches = hook_diam_mm/(2*mm_per_inch); //converted to inches 
			var hook_r = inches_to_pixels(hook_r_inches);

			/*var prev_stitch = undefined;
			var cur_stitch = undefined;
			var one_row = true;*/

			/// Set up stitch storage ////
			var world = [[]]; // an array of arrays containing arrays of length 2 ([funcname, args]) 
			//ignores all turns and vertical stitches
			var world_r = 0;
			var world_c = 0;
			var cur_world_r = 0; // index within world of the stitch being drawn in a given moment
			// after draw_world, cur_world_r should evaluate to world_r
			// and cur_world_c should evaluate to world_c, given that
			// the #rows and columns are the same throughout the array (not necessarily the case)
			var cur_world_c = 0;
			//
			//all depend on accurate cur_world_r and cur_world_l vals
			function get_from_world(r, c, i){ 
			//produces undefined vals instead of raising errors
				i = i || 0;
				if ((r >= 0 && r <= world_r) && (c >= 0 && (c <= world_c || world_c == -1))){ // r and c are valid
					slot_from_world = world[r][c];
					if ((slot_from_world != undefined) && ((i >= 0) && (slot_from_world.length > i))){
						//a bit inelegant but assumed short-circuiting did not seem to work correctly
						return world[r][c][i];
					}
				}
				return undefined;
			}
			function last_stitch(r, c, i){
				r = r || cur_world_r;
				c = c || cur_world_c;
				i = i || 0;
				//get last from prev row if slot is the first in a row
				if (c == 0){
					r = r - 1;
					if ((r >= 0 && r <= world_r)){
						//get correct above column
						new_c = world[r].length - 1;
						return get_from_world(r, new_c, world[r][new_c].length - 1);
					}
				}
				else {return get_from_world(r, c - 1, i);}
				
			}
			function cur_stitch(){return get_from_world(cur_world_r, cur_world_c);}
			//function next_stitch(){return get_from_world(cur_world_r, cur_world_c + 1);}
			function above_stitch(){
				r = cur_world_r + 1;
				if ((r >= 0 && r <= world_r)){
					//get correct above column
					return get_from_world(r, world[r - 1].length - 2 - cur_world_c);
				}
			}
			//function below_stitch(){return get_from_world(cur_world_r - 1, cur_world_c);}

			var row_max_height = 0;
			var tailed = false;
			var past_row_widths = [];
			var cur_row_widths = [];

			// Smooth curve over this many points /// delete
			//var numPoints = 100;

			// using "_" naming convention for all geometry funcs to 
			// differentiate custom functions and THREE.js builtins

			// Given a CatmullRomCurve3, creates a THREE.geometry  
			// that follows this curve, smoothed over n_points points.
			// Possible helper for all custom geometry functions.
			function path_geometry_from_curve(n_points, curve){
				new_geom = new THREE.Geometry();
				geom_points = curve.getPoints(n_points);

				for(var i = 0; i < n_points; i++){
				    new_geom.vertices.push(geom_points[i]);  
				}
				return new_geom;
			}
			///////////// GEOMETRIES ////////////
			// Makes a (starting) tail yarn end 
			// starting at (xpos, ypos, zpos)
			function tail_geometry(xpos, ypos, zpos){
				tail_curve = new THREE.CatmullRomCurve3([
				   new THREE.Vector3(xpos, ypos, zpos),
				   new THREE.Vector3(xpos + direction*(tail_length_pixels/2), ypos - (tail_length_pixels/5), zpos),
				   new THREE.Vector3(xpos + direction*tail_length_pixels, ypos, zpos),
				]);
				tail_geom = new THREE.TubeGeometry(tail_curve, 64, pix_per_radius);
				tailed = true;
				//set_global_coords(xpos + direction*tail_length_pixels, ypos, zpos);
				return tail_geom;
			}

			function slip_geometry(startx, starty, startz){
				slip_array = [new THREE.Vector3(startx, starty, startz)];

				xpos = startx;
				ypos = starty;
				zpos = startz;

				yzloop_end_theta = (2*math.pi);

				for (var t = 0; t < yzloop_end_theta + (math.pi/8); t = t + (math.pi/8)){ 
					yz_x = xpos - direction*((t * 2 * pix_per_radius)/(yzloop_end_theta)); 
					//x slowly moves toward xpos + 2* radius
					yz_y = ypos - (2*pix_per_radius*Math.cos(t));
					yz_z = zpos - (4*pix_per_radius*Math.sin(t));

					slip_array.push(new THREE.Vector3(yz_x, yz_y, yz_z));
					if (Math.abs(yzloop_end_theta-t) < .0000000001){
					//note: this is not the same vals for x and z as
					// the end points for yzloop, due to precision problems for Math.pi, making t off significantly from
					// yzloop_end_theta 
					// have reverted back to just making the wanted end point values here. 
						xpos = xpos - direction*(2 * pix_per_radius);
						ypos = ypos -  (2 * pix_per_radius * Math.cos(yzloop_end_theta));
						zpos = zpos -  (4 * pix_per_radius * Math.sin(yzloop_end_theta));
					}
				}

				
				connector_array = [
					//connect to (desired) end of hook_loop
					new THREE.Vector3(xpos, ypos, zpos), 
					new THREE.Vector3(xpos, ypos, zpos - (1* pix_per_radius)),
					new THREE.Vector3(xpos, ypos + (1 * pix_per_radius), zpos - (2* pix_per_radius)),
					new THREE.Vector3(xpos + direction*(1* pix_per_radius), ypos + (2 * pix_per_radius), zpos - (2* pix_per_radius)),
					new THREE.Vector3(xpos + direction*(2* pix_per_radius), ypos + (1 * pix_per_radius), zpos - (2* pix_per_radius)),
				];
				slip_array = slip_array.concat(connector_array);
				
				xpos = xpos + direction*(2 * pix_per_radius);
				ypos = ypos; //+ (1 * pix_per_radius);
				zpos = zpos - (3 * pix_per_radius);

				///
				loop_r = hook_r + pix_per_radius;
				loop_center_x = xpos + direction*loop_r;
				loop_center_z = zpos + loop_r;
				loop_array = [];

				loop_start_theta = -math.pi/2;//Math.atan(xpos/zpos);//
				slip_array.push(
					new THREE.Vector3(loop_center_x + loop_r*math.cos(loop_start_theta), ypos, 
						loop_center_z + loop_r*math.sin(loop_start_theta)));

				loop_theta_d= math.pi;//angular displacement

				for (var t = loop_start_theta; t < loop_start_theta + loop_theta_d + (math.pi/16); t = t + (math.pi/16)){ 
					loop_x = loop_center_x + direction*loop_r*math.cos(t);
					loop_z = loop_center_z + loop_r*math.sin(t);

					loop_array.push(new THREE.Vector3(loop_x, ypos, loop_z));

					if ((t + (math.pi/16)) >= loop_start_theta + loop_theta_d+ (math.pi/16)){// last iteration
						xpos = loop_x;
						zpos = loop_z;
					}
				}
				slip_array = slip_array.concat(loop_array);

				//end of slip, after hook loop
				slip_array.push(new THREE.Vector3(startx, starty, zpos - pix_per_radius));
				slip_array.push(new THREE.Vector3(startx + 3*pix_per_radius, starty, zpos - pix_per_radius));
				slip_array.push(new THREE.Vector3(startx + 3*pix_per_radius, starty, zpos - pix_per_radius));

				xpos = startx - direction*3*pix_per_radius;
				ypos = starty;
				zpos = zpos - pix_per_radius;
				//curve back around to "point" in the correct direction
				//curve on the xy plane
				
				reorient_center_x = xpos + direction*2*pix_per_radius;
				reorient_center_y = ypos - 4*pix_per_radius;

				reorient_start_theta =  7*math.pi/4;
				reorient_displacement = 5*math.pi/4;

				reorient_array = [new THREE.Vector3(reorient_center_x - direction*3*pix_per_radius*math.cos(reorient_start_theta),
					reorient_center_y - 1*pix_per_radius*math.sin(reorient_start_theta),
					zpos - ((reorient_start_theta * 2 * pix_per_radius)/(reorient_start_theta + reorient_displacement))),
				new THREE.Vector3(reorient_center_x,
					reorient_center_y - 1*pix_per_radius*math.sin(reorient_start_theta),
					startz),
				new THREE.Vector3(startx +direction*2*pix_per_radius,
					starty,
					startz)
				];

				slip_array = slip_array.concat(reorient_array);
				//set_global_coords(startx +direction*2*pix_per_radius, starty, startz);

				slip_curve = new THREE.CatmullRomCurve3(slip_array);
				slip_geom = new THREE.TubeGeometry(slip_curve, 64, pix_per_radius);
				return slip_geom;
			}

			function ch_array(startx, starty, startz){ 
				//just a helper, not intended to be
				//publically accessible
				xpos = startx;
				ypos = starty;
				zpos = startz;
				chain_array = [new THREE.Vector3(xpos, ypos, zpos)]

				xpos = xpos + direction*3*pix_per_radius;
				zpos = zpos - pix_per_radius;

				chain_array.push(new THREE.Vector3(xpos, ypos, zpos));
				
				if (above_stitch() == undefined){ //show nice and plump
					loop_z_r = hook_r + pix_per_radius;
				}
				else{ //squeezed
					loop_z_r = pix_per_radius;
				}
				loop_x_r = hook_r + pix_per_radius;
				loop_center_x = xpos + direction*loop_r;
				loop_center_z = start_z;

				loop_start_theta = -math.pi/2;//Math.atan(xpos/zpos);

				loop_theta_d = math.pi;//angular displacement? -math.pi/2;?
				loop_x_min = loop_center_x; // change throughout loop to get x_change for chain, doesn't affect visual rendering

				for (var t = loop_start_theta; t <= loop_start_theta + loop_theta_d; t = t + (math.pi/16)){ 
					loop_x = loop_center_x + direction*loop_x_r*math.cos(t);
					loop_y = ypos; //- 2*t*Math.abs(loop_x/xpos);// - (2*pix_per_radius);""
					if (loop_x < loop_x_min){loop_x_min = loop_x;}
					loop_z = loop_center_z + loop_z_r*math.sin(t);

					chain_array.push(new THREE.Vector3(loop_x, loop_y, loop_z));

					if ((t + (math.pi/16)) > loop_start_theta + loop_theta_d){// last iteration
						xpos = loop_x;
						ypos = loop_y;
						zpos = loop_z;
					}
				}

				//hook in previous loop
				if (last_stitch() == "slip"){
					hook_xpos = startx + direction*3*pix_per_radius;
				}
				else if (cur_stitch() == "v_chain" || cur_stitch() == "v_chain_with_twist"){
					hook_xpos = startx - direction*2*pix_per_radius;
				}
				else{ hook_xpos = startx; }
				chain_array.push(new THREE.Vector3(
						hook_xpos,
						ypos, startz + 2*pix_per_radius));
				chain_array.push(new THREE.Vector3(
						hook_xpos,
						ypos - 2*pix_per_radius, startz + 2*pix_per_radius));
				/*chain_array.push(new THREE.Vector3(startx + direction*5*pix_per_radius,
					ypos, zpos - 2*pix_per_radius));
				chain_array.push(new THREE.Vector3(startx + direction*2*pix_per_radius,
					ypos - 3*pix_per_radius, zpos - 2*pix_per_radius));*/
				//xpos  = startx + direction*5*pix_per_radius;
				ypos = ypos - 2*pix_per_radius;
				reorient_center_x = xpos + direction*pix_per_radius;
				reorient_center_y = ypos - 3*pix_per_radius;

				reorient_start_theta =  7*math.pi/4;
				reorient_displacement = 5*math.pi/4;

				reorient_array = [
				new THREE.Vector3(reorient_center_x,
					reorient_center_y - 1*pix_per_radius*math.sin(reorient_start_theta),
					startz),
					//zpos - ((reorient_start_theta * 2 * pix_per_radius)/(reorient_start_theta + reorient_displacement))),
				new THREE.Vector3(reorient_center_x,
					//reorient_center_y - 1*pix_per_radius*math.sin(reorient_start_theta),
					starty,
					startz)
				];
				//set_global_coords(reorient_center_x, starty, startz);
				if (stitch_x_change["chain"] == undefined){
					stitch_x_change["chain"] = math.abs(reorient_center_x - startx);
					stitch_x_mag["chain"] = math.abs(loop_x_min - startx);
				}

				chain_array = chain_array.concat(reorient_array);
				return chain_array;
			}

			function chain_geometry(startx, starty, startz){
				chain_array = ch_array(startx, starty, startz);
				chain_curve = new THREE.CatmullRomCurve3(chain_array);
				chain_geom = new THREE.TubeGeometry(chain_curve, 64, pix_per_radius);
				return chain_geom;
			}

			function v_chain_geometry(startx, starty, startz){
				chain_array = ch_array(startx, starty, startz);
				last_point = chain_array.pop();
				chain_array.push(last_point);

				// with a rotation about z axis of 3pi/2, axis:
				// x -> y
				// y -> x
				// z doesn't change
				//set_global_coords(last_point.y, startx - last_point.x + starty, last_point.z);
				if (stitch_x_change["v_chain"] == undefined){
					stitch_x_change["v_chain"] = (last_point.y - starty);
					stitch_y_change["v_chain"] =
						startx - last_point.x;
						//NOT allowed to call v_chain before chain
						//might want to implememt 
						// a called-stiches list if it doenst affect
						// efficiency too much
					stitch_z_change["v_chain"] =
						last_point.z - startz;
				}

				chain_curve = new THREE.CatmullRomCurve3(chain_array);
				chain_geom = new THREE.TubeGeometry(chain_curve, 64, pix_per_radius);

				/////rotate//////
				//rotate around origin
				chain_geom.translate(-startx,-starty,-startz);
				chain_geom.rotateZ(3*math.pi/2);
				//move back to appropriate position
				chain_geom.translate(startx, starty, startz);
				return chain_geom;
			}
			function v_chain_with_twist_geometry(startx, starty, startz){
			chain_array = ch_array(startx, starty, startz);
				//get xyzpos vals from last vector in chain_array
				chain_last = chain_array.pop();
				chain_array.push(chain_last);

				xpos = post_startx = chain_last.x + pix_per_radius;
				ypos = post_starty = chain_last.y + pix_per_radius;
				zpos = post_startz = chain_last.z + pix_per_radius;

				chain_post_intersect = new THREE.Vector3(
					xpos, ypos, zpos);
				chain_array.push(chain_post_intersect);

				post_chain_array = [chain_post_intersect]; //connect the two geometries explicitly

				loop_r = hook_r + pix_per_radius;
				loop_center_x = xpos + direction*loop_r;
				loop_center_z = zpos; // maybe make this related to direction?


				loop_start_theta = -3*math.pi/2;
				loop_theta_d = math.pi;//angular displacement
				//crucial that this is the same as loop_theta_d in chain. 

				for (var t = loop_start_theta; t <= loop_start_theta + loop_theta_d; t = t + (math.pi/16)){ 
					loop_x = loop_center_x -direction*loop_r*math.cos(t);
					if (loop_x < loop_x_min){loop_x_min = loop_x;}
					loop_z = loop_center_z + loop_r*math.sin(t);

					post_chain_array.push(new THREE.Vector3(loop_x, ypos, loop_z));

					zpos = loop_z;
				}


				crossover_array = 
				[new THREE.Vector3(post_startx + direction*2*pix_per_radius, 
					post_starty + pix_per_radius, 
					(post_startz + zpos)/2)];
				last_point = new THREE.Vector3(post_startx - direction*2*pix_per_radius, 
					post_starty - 1*pix_per_radius, 
					post_startz + 2*pix_per_radius);
				crossover_array.push(last_point);
				post_chain_array = post_chain_array.concat(crossover_array);				
				
				if (stitch_x_change["v_chain_with_twist"] == undefined){
					stitch_x_change["v_chain_with_twist"] = last_point.x - post_startx;
					stitch_y_change["v_chain_with_twist"] =
						stitch_x_change["chain"] + post_starty;
						//NOT allowed to call v_chain before chain
						//might want to implememt 
						// a called-sttiches list if it doenst affect
						// efficiency too much
					stitch_z_change["v_chain_with_twist"] =
						last_point.z - post_startz;
				}
				//
				//set_global_coords(last_point.x - post_startx + startx, stitch_x_change["chain"] + post_starty + starty, last_point.z- post_startz + startz);
				//establish both geometries
				post_chain_curve = new THREE.CatmullRomCurve3(post_chain_array);
				post_chain_geom = new THREE.TubeGeometry(post_chain_curve, 64, pix_per_radius);
				chain_curve = new THREE.CatmullRomCurve3(chain_array);
				chain_geom = new THREE.TubeGeometry(chain_curve, 64, pix_per_radius);

				/////rotate//////
				//rotate both around origin
				chain_geom.translate(-startx,-starty,-startz);
				post_chain_geom.translate(-post_startx,-post_starty,-post_startz);
				//rotate
				chain_geom.rotateZ(3*math.pi/2);
				post_chain_geom.rotateZ(math.pi - math.pi/16);
				//move back to appropriate positions
				chain_geom.translate(startx, starty, startz);
				post_chain_geom.translate(startx, starty + (startx - post_startx), startz);
				//merge geoms
				//post_chain_geom.updateMatrix();
				chain_geom.merge(post_chain_geom, post_chain_geom.matrix);
				return chain_geom;
			}

			function turn(){
				direction = -1*direction;
				//something to do with new row y?
			}

			function single_geometry(startx, starty, startz){
				xpos = startx;
				ypos = starty;
				zpos = startz;
				single_array = [];
				console.log("last stitch", last_stitch());

				if ((last_stitch() == undefined) || (last_stitch() == "turn")){ // for now, may make if last is turn
					single_array = [
					new THREE.Vector3(xpos + direction*pix_per_radius,
					ypos - pix_per_radius, zpos - pix_per_radius),
					//caps onto the preceeding part of v_chain_with_twist, 
					// just for visual fluidity/smoothness, but messes with uarn radius
					//may remove later, but looks much better with this point
					new THREE.Vector3(xpos, ypos, zpos)];

					edge_loop = []; // at one of the edges of the piece
					//** only drawn if its the next stitch directly after a v_chain_with_twist
					//axis radii
					edge_x_r = direction*2*pix_per_radius;
					edge_y_r = (pix_per_radius + stitch_y_change["v_chain_with_twist"])/2;
					edge_z_r = pix_per_radius;

					//(~ellipse) center coordinates
					edge_center_x = xpos - edge_x_r - pix_per_radius;
					edge_center_y = ypos - edge_y_r - pix_per_radius;
					edge_center_z = zpos - edge_z_r - pix_per_radius;


					t = 0;
					p = 0; //theta and phi
					t_end = math.pi/2;//2*math.pi;
					p_end = t_end/2;
					t_increment = (t_end-t)/32;
					p_increment = t_increment/2;

					while (t <= t_end && p <= p_end){
						edge_x = edge_center_x - direction*edge_x_r*math.sin(p)*math.cos(t);
						edge_y = edge_center_y - edge_y_r*math.sin(p)*math.sin(t);
						edge_z = edge_center_z + edge_z_r*math.cos(p);
						edge_loop.push(new THREE.Vector3(edge_x, edge_y, edge_z));

						t = t + t_increment;
						p = p + p_increment; 
						//p takes double the time to get to same measure as t

						if (t_end - t < 0.0000000001){ //some floating point error
							xpos = edge_x;
							ypos = edge_y;
							zpos = edge_z;
						}
					}
					single_array = single_array.concat(edge_loop);

				
					under_startx = xpos + direction*2*pix_per_radius;
					under_starty = ypos - 2*pix_per_radius;
					under_startz = zpos;

					under_loop = [
						new THREE.Vector3(under_startx, under_starty, under_startz),
						new THREE.Vector3(
							under_startx + direction*2*pix_per_radius, 
							under_starty, 
							under_startz),
						new THREE.Vector3(
							under_startx + direction*3*pix_per_radius, 
							under_starty + pix_per_radius, 
							under_startz),
						new THREE.Vector3(
							under_startx + direction*5*pix_per_radius, 
							under_starty + pix_per_radius, 
							under_startz - 3*pix_per_radius)];

					xpos = under_startx + direction*5*pix_per_radius;
					ypos = under_starty + pix_per_radius;
					zpos = under_startz - 3*pix_per_radius;				
				}
				else{
					single_array = [new THREE.Vector3(xpos, ypos, zpos)];

					under_loop = [
						new THREE.Vector3(xpos, ypos, zpos),
						new THREE.Vector3(
							xpos + direction*2*pix_per_radius, 
							ypos + pix_per_radius, 
							zpos - 3*pix_per_radius)];

					xpos = xpos + direction*2*pix_per_radius;
					ypos = ypos + pix_per_radius;
					zpos = zpos - 3*pix_per_radius;	

				}
				

				single_array = single_array.concat(under_loop);

				//// three loops make up the "middle" loop between top twist and bottom chain
				//all have the same r 
				middle_r = 2*pix_per_radius;
				middle_loop = [];

				// small loop to above the stitch below
				up_from_center_y = ypos + middle_r;// + pix_per_radius;
				up_from_center_z = zpos + middle_r;

				for (var t = -math.pi/2; t < 0; t = t + math.pi/16){
					up_from_y = up_from_center_y + middle_r*Math.cos(t);
					up_from_z = up_from_center_z + middle_r*Math.sin(t);
					middle_loop.push(new THREE.Vector3(xpos, up_from_y, up_from_z));
				}
				ypos = up_from_center_y + middle_r*Math.cos(0);
				zpos = up_from_center_z + middle_r*Math.sin(0);
				//
				xz_loop = []; // under loop on xz
				xz_center_x = xpos + direction*middle_r - direction*pix_per_radius;
				xz_center_z = zpos + middle_r + pix_per_radius;

				for (var t = 0; t < math.pi + math.pi/16; t = t + math.pi/16){
					xz_x = xz_center_x - middle_r*Math.cos(t);
					xz_z = xz_center_z + middle_r*Math.sin(t);
					middle_loop.push(new THREE.Vector3(xz_x, ypos, xz_z));
				}
				xpos = xz_center_x - middle_r*Math.cos(math.pi);
				zpos = xz_center_z + middle_r*Math.sin(math.pi);
				//
				//down_from_loop, opposite of (and based on) up_from_loop
				down_from_center_y = ypos - middle_r;
				down_from_center_z = zpos - middle_r;

				for (var t = 0; t < 7*math.pi/4 + math.pi/16; t = t + math.pi/16){
					down_from_x = xpos - direction*t/(math.pi) - direction*pix_per_radius; //to make room for reorient later
					down_from_y = down_from_center_y + middle_r*Math.cos(t);
					down_from_z = down_from_center_z - (middle_r+pix_per_radius)*Math.sin(t);
					middle_loop.push(new THREE.Vector3(down_from_x, down_from_y, down_from_z));
				}
				single_array = single_array.concat(middle_loop);
				//update coords after loop
				xpos = xpos - direction*(7/4);
				ypos = down_from_center_y + middle_r*Math.cos(7*math.pi/4);
				zpos = down_from_center_z - (middle_r+pix_per_radius)*Math.sin(7*math.pi/4);
				//
				//new coord update for post single
				ypos = ypos + stitch_y_change["v_chain_with_twist"]/2;
				zpos = zpos - 2*pix_per_radius;
				single_post_intersect = new THREE.Vector3(xpos, ypos, zpos);
				single_array.push(single_post_intersect);
				
				// based in v_chain_with_twist
				post_single_array = [single_post_intersect]; //connect the two geometries explicitly

				loop_x_r = 2*pix_per_radius + stitch_x_change["chain"]/2;
				loop_z_r = hook_r + pix_per_radius;
				loop_center_x = xpos + direction*loop_r;
				loop_center_z = 0; //force to 0 for alignment

				loop_start_theta = -3*math.pi/2;
				loop_theta_d = math.pi;//angular displacement
				//crucial that this is the same as loop_theta_d in chain. 

				for (var t = loop_start_theta; t <= loop_start_theta + loop_theta_d +(math.pi/16); t = t + (math.pi/16)){ 
					loop_x = loop_center_x - direction*loop_x_r*math.cos(t);
					loop_z = loop_center_z + loop_z_r*math.sin(t);

					post_single_array.push(new THREE.Vector3(loop_x, ypos, loop_z));
				}
				xpos = loop_center_x - direction*loop_x_r*math.cos(loop_start_theta + loop_theta_d);
				zpos = loop_center_z + loop_r*math.sin(loop_start_theta + loop_theta_d);
				post_single_array.push( // finish loop
					new THREE.Vector3(xpos, ypos, zpos));	
				post_single_array.push( // bring coords back to edge of the previous loop stitch
					new THREE.Vector3(xpos - direction*2*pix_per_radius, ypos, zpos + pix_per_radius));	
				post_single_array.push(
					new THREE.Vector3(xpos, ypos, zpos + pix_per_radius));

				zpos = zpos + pix_per_radius;	
				//
				reorient_array = [];

				reorient_r = 2*pix_per_radius;
				reorient_center_x = xpos - direction*reorient_r/2;
				reorient_center_y = ypos - reorient_r/2;

				for (var t = math.pi/4; t <= math.pi +(math.pi/16); t = t + (math.pi/16)){ 
					reorient_x = reorient_center_x + direction*reorient_r*math.cos(t);
					reorient_y = reorient_center_y + reorient_r*math.sin(t);
					reorient_z = zpos + t/(2*math.pi);

					reorient_array.push(new THREE.Vector3(reorient_x, reorient_y, reorient_z));
				}
				//fix coords after loop
				xpos = reorient_center_x + direction*reorient_r*math.cos(math.pi);
				ypos = reorient_center_y + reorient_r*math.sin(math.pi);
				zpos = zpos + 4*pix_per_radius;

				reorient_array.push(
					new THREE.Vector3(xpos, 
					ypos - stitch_y_change["v_chain_with_twist"]/2 + 2*pix_per_radius,//added radius to make space to turn 
					zpos));
				//record change
				ypos = ypos - stitch_y_change["v_chain_with_twist"]/2 + 2*pix_per_radius;

				incline_loop = [];
				incline_x_r = 2*pix_per_radius;
				incline_y_r = (stitch_y_change["v_chain_with_twist"]-pix_per_radius)/4;

				incline_center_x = xpos + direction*incline_x_r;
				incline_center_y = ypos - incline_y_r/2;

				for (var t = 0; t <= math.pi/2 +(math.pi/16); t = t + (math.pi/16)){ 
					incline_x = incline_center_x + direction*incline_x_r*math.cos(t);
					incline_y = incline_center_y - incline_y_r*math.sin(t);

					incline_loop.push(new THREE.Vector3(incline_x, incline_y, zpos));
				}
				//fix coords settings
				xpos = incline_center_x + direction*incline_x_r*math.cos(math.pi/2);
				ypos = incline_center_y - incline_y_r*math.sin(math.pi/2);

				//move coords
				ypos = ypos - pix_per_radius;
				zpos = zpos + 2*pix_per_radius;
				incline_loop.push(new THREE.Vector3(xpos, ypos, zpos));

				surface_loop = []; // on the surface of the piece
				surface_x_r = 2*pix_per_radius;
				surface_y_r = pix_per_radius;	

				surface_center_x = xpos + surface_x_r;
				surface_center_y = ypos - surface_y_r;

				for (var t = 0; t < math.pi/2 + math.pi/16; t = t + math.pi/16){
					xpos = surface_center_x - surface_x_r*math.cos(t);
					ypos = surface_center_y - surface_y_r*math.sin(t);
					surface_loop.push(new THREE.Vector3(xpos, ypos, zpos));
				}
				surface_loop.push(new THREE.Vector3(
					xpos + direction*pix_per_radius, 
					ypos, 
					zpos));
				surface_loop.push(
					new THREE.Vector3(
						xpos,// + direction*pix_per_radius, 
						ypos, 
						zpos - 3*pix_per_radius));
				//xpos = xpos + direction*pix_per_radius;
				//ypos = ypos + pix_per_radius;　
				zpos = zpos - 3*pix_per_radius;

				incline_loop = incline_loop.concat(surface_loop);

				stitch_x_change["single"] = xpos - startx;
				if ((last_stitch() == undefined) || (last_stitch() == "turn")){
					stitch_y_change["single"] = ypos - starty;
					stitch_z_change["single"] = zpos - startz;
				}
				else{
					stitch_y_change["single"] = 0; //force y to 0
					stitch_z_change["single"] = 0; // z seems to already be 0. 
				}
				console.log("stitch changes", stitch_x_change["single"], stitch_y_change["single"],stitch_z_change["single"])

				reorient_array = reorient_array.concat(incline_loop);
				post_single_array = post_single_array.concat(reorient_array);

				single_array = single_array.concat(post_single_array);
				single_curve = new THREE.CatmullRomCurve3(single_array);
				single_geom = new THREE.TubeGeometry(single_curve, 64, pix_per_radius);
				//single_geom.merge(post_single_geom, post_single_geom.matrix);
				return single_geom;
			}

			stitch_x_change = { // end_x - start_x, not necessarily the same as total magnitude
				//all positive values, sign is denoted by the direction variable
				// in pixels
				//some will be dynamically reset on func run for geometries
				"tail": tail_length_pixels,
				"slip": 2*pix_per_radius,
				"chain": undefined, 
				"v_chain_with_twist": undefined
			};
			stitch_y_change = {
				"tail": 0,
				"slip": 0,
				"chain": 0, 
				"v_chain_with_twist": undefined
			};
			stitch_z_change = {
				"tail": 0,
				"slip": 0,
				"chain": 0, 
				"v_chain_with_twist": undefined
			};
			/////
			stitch_x_mag = { // think of magnitiude as total width
				// from leftmost x to rightmost x
				//all positive values, sign is denoted by the direction variable
				"tail": tail_length_pixels,
				"slip": 2*pix_per_radius,
				"chain": undefined,
				"v_chain_with_twist": undefined
			};
			/*stitch_y_mag = { //need to define later
				"tail": 0,
				"slip": 0,
				"chain": 0,
				"v_chain": undefined,
				"single": undefined
			};
			stitch_z_mag = {
				"tail": 0,
				"slip": 0,
				"chain": 0,
				"v_chain": undefined
			};*/

			///////////// SCENE ADD ////////////
			function draw_to_scene(stitch, material){
				material = material || yarn_material1;//should never be called, but just in case
				if (stitch == "turn"){turn();}
				else{
					/*prev_stitch = cur_stitch;
					cur_stitch = stitch;*/
					geom_call = stitch + "_geometry";
					stitch_geometry = window[geom_call](x, y, z); //calls correct symbol based on funcname
					scene.add(new THREE.Line(stitch_geometry, material)); 
					//create THREE.Line instead for unfilled model (better able to see individual lines),
					// THREE.Mesh for a smoother model

					x = x + direction * stitch_x_change[stitch]; //only x should change for most stitches,
					// especially all that are repeated
					y = y + stitch_y_change[stitch]; 
					z = z + stitch_z_change[stitch]; 
				}
			}

			/// Testing specific function calls. Set default/placeholder here
			direction = -1 ;
			draw_to_scene("tail", yarn_material0);
			draw_to_scene("slip", yarn_material1);
			draw_to_scene("chain", yarn_material2);
			draw_to_scene("chain", yarn_material2);draw_to_scene("chain", yarn_material2);draw_to_scene("chain", yarn_material2);draw_to_scene("chain", yarn_material2);draw_to_scene("chain", yarn_material2);draw_to_scene("chain", yarn_material2);draw_to_scene("chain", yarn_material2);

			draw_to_scene("v_chain_with_twist", yarn_material1);
			turn();

			draw_to_scene("single", yarn_material3);draw_to_scene("single", yarn_material3);

			function render() {
				var delta = clock.getDelta();
				requestAnimationFrame( render );
				cameraControls.update(delta);
				renderer.render( scene, camera );
			}
			render();


			/// TEXTAREA INPUT

			$("#textarea").keypress(function(event){
			    if (event.which == 59){ // on semicolon, parse input
			    	//establish defaults
			    	default_and_parse();
			    }
			})

			function default_and_parse(){
				//ypos_0 = $("#container").height() - 80;
				x = start_x;
				y = start_y;
				z = start_z;
				direction = -1;
				row_max_height = 0;
				world = [[]]; // start with one row, one column
				world_r = 0;
				world_c = 0;
				/*prev_stitch = undefined;
				cur_stitch = undefined;
				one_row = true; //first row only*/
				scene = new THREE.Scene(); // reset scene
				scene.add( axisHelper );
				tailed = false; // didn't "start" string yet
				selected_yarn = default_yarn;

		    	parse_input($("#textarea").val()); //style choice to pass the string. 
			}

			function parse_input(pattern_string){
				clean_pattern = pattern_string.replace(/\s+/g, '');
				if (pattern_string.indexOf("turn") == -1){one_row = true;}
				else{one_row = false;}

				func_call_strings = clean_pattern.split(";");
				//split separates different functions, slice removes the last (empty) element caused by the last ";"

				f = 0;
				while ((f < func_call_strings.length) && (func_call_strings[f] !== "")){
					//while loop instead of for loop for repeat implementation.

					split_func_call = func_call_strings[f].split("(");
					// [0]: function name, [1]: function arguments (+ ")" in most cases)
					func_name = (split_func_call[0]).toLowerCase();
					/*if ((f == 0) && (tailed == false)){ //set to true in tail_geometry
						draw_to_scene("tail", selected_yarn);
						draw_to_scene("slip", selected_yarn);
					}*/

					if (func_name == "turn"){ //turn();
						/*n_verts = Number(split_func_call[1].slice(0, -1));
						for (var v = 0; v < n_verts - 1; v++){ 
							draw_to_scene("v_chain", selected_yarn);
						}
						draw_to_scene("v_chain_with_twist", selected_yarn);
						turn();*/
						n_verts = Number(split_func_call[1].slice(0, -1));
						world[world_r].push([]); // add column at world_c index
						world_c++;
						for (var v = 0; v < n_verts - 1; v++){ //all but last
							world[world_r][world_c].push("v_chain");
						}
						world[world_r][world_c].push("v_chain_with_twist");//last turn index
						world[world_r][world_c].push("turn");//actually change direction
						world_r++;
						//make empty world_r exist within world
						world.push([]);
						world_c = -1;
					}
					else if (func_name == "color"){ 
						selected_yarn = new THREE.MeshBasicMaterial( {color: split_func_call[1].slice(0, -1)}); // for string colors only
					}
					else if (func_name == "repeat"){
						to_parse = func_call_strings[f].substring(7)+";"; //"repeat(" has 7 characters

						while (f < func_call_strings.length){
							f++;
							next_split = func_call_strings[f];
							// EG "treble(2)"

							if (next_split.indexOf(',') < 0){
								to_parse = to_parse + next_split + ";";
							}
							else{ break;}
						}

						//removes "," since it should be the zero-th char in this string 
						// as well as the last character, ")"
						n_repeats = Number(next_split.slice(1, -1));

						for(r = 0; r < n_repeats; r++){
							parse_input(to_parse);
						}
					}


					else{
						//cut off last ")" char
						n_stitches = Number(split_func_call[1].slice(0, -1));
						for (var s = 0; s < n_stitches; s++){
							world[world_r].push([func_name]); // at column world_c
							//world_c++;
						}
						world_c = world_c + n_stitches - 1;
						/*for (var s = 0; s < n_stitches; s++){
							draw_to_scene(func_name, selected_yarn);
						}*/
					}	

					f++;
				}
				console.log(world);
				draw_world();
			}
			function draw_world(){
				draw_to_scene("tail", selected_yarn); //add material here
				draw_to_scene("slip", selected_yarn);
				//assumes there are world_r + 1 rows and world_c + 1 cols
				console.log(world_r, world_c);
				for (var r = 0; r < world_r + 1; r++){
					for (var c = 0; c < world[r].length; c++){
						cur_col = world[r][c];
						for (var fun = 0; fun < cur_col.length; fun++){
							cur_world_r = r;
							cur_world_c = c;
							draw_to_scene(cur_col[fun], selected_yarn);
						}
					}	
				}
				/*//check:
				console.log("world_r and cur_world_r", world_r >= cur_world_r);
				console.log("world_c and cur_world_c", world_c >= cur_world_c);*/
			}
			$( window ).resize(function() {
				$("#textarea").width('100%');
				header_spacing();
				default_and_parse();
			});

		</script>
		
	</body>
</html>
	
	