<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Strung</title>
		<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<link href='https://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/visualize.css">
		<script type="text/javascript">
		/// set up any formulas and formal definitions
			function getWindowWidth() {
				return window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth||0;
			}
			function getWindowHeight() {
				return window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight||0;
			}	
			var mm_per_inch = 25.4;

			/*THREE.CylinderCurvedSurfaceGeometry = function(radius, height, startAngle, endAngle, horizontalSegments, verticalSegments) {
				//optional params
				startAngle = startAngle || Math.PI/2;
				endAngle = endAngle || Math.PI;
				horizontalSegments = horizontalSegments || 25;
				verticalSegments = verticalSegments || 25;
				//

			    var width = radius * 2 * Math.PI;
			    var plane = new THREE.PlaneGeometry(width, height, horizontalSegments, verticalSegments);
			    var index = 0;

			    for(var i=0; i<=verticalSegments; i++) {
			        for(var j=0; j<=horizontalSegments; j++) {
			            var angle = startAngle + (j/horizontalSegments)*(endAngle - startAngle);
			            plane.vertices[index].z = radius * Math.cos(angle);
			            plane.vertices[index].x = radius * Math.sin(angle);
			            index++;
			        }
			    }

			    return plane;
			}*/

		</script>

	</head>
	<body>
	
	<div class="header">
		<a id="site_name" href="index.html">STRUNG</a><!--127.5px-->

		<!--site_nav floats backward, this is in reverse order:-->
		<a class="site_nav" id="docs" href="documentation.html">Documentation</a> <!--150.797px-->
		<a class="site_nav" id="textify" href="textify.html">Textify</a><!--68.125px-->
		<a class="site_nav" id="visualize" href="visualize.html">Visualize</a><!--86.4844px-->
		<a class="site_nav" id="chartify" href="chartify.html">Chartify</a> <!--79.8438px-->
	</div>
		<script type="text/javascript">
			header_spacing();
			function header_spacing(){
				window_w = getWindowWidth();
				title_w = 127.5 + window_w*.1; //width + padding-left
				remaining_width = window_w - title_w - 150.797 - 68.125 - 86.4844 - 79.8438 - 3*window_w*.05;
				//results that: site_name has a padding_left of 10%, a padding_right of 10%, and
				// documentation has a padding_right of 5%
				$(".site_nav").css("padding-left", remaining_width/4);
			}
			//// Scene Setup //////
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			camera.position.z = 200;

			var renderer = new THREE.WebGLRenderer( { alpha: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);

			var cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
			cameraControls.target.set(0, 0, 0);
			var clock = new THREE.Clock();

			//scaling depends on yarn being used
			//as wpi gets larger, "zoom in" closer--> set yarn radius (in inches) to pixel ratio for simplicity
			//wraps-per-inch, a standard metric for yarn purchase and storage 
			var yarn_wpi = 5; // where a wrap is defined as the diameter; wrap = 2 * radius
			// yarn radius in inches is 1/(2*yarn_wpi)
			var pix_per_radius = 2; // equiv to yarn radius in pixels
			// 2 for standard/view mode, 10 for "loosening"

			function inches_to_pixels(n_inches){
				return n_inches * yarn_wpi * 2 * pix_per_radius; 
			}
			function pixels_to_inches(n_pixels){
				return n_pixels * (1/pix_per_radius) * .5 * (1/yarn_wpi); 
			}

			//// Three.js settings for all stitches //////
			//var yarn_geometry = new THREE.CylinderGeometry(.1, .1, 2, 20);
			var yarn_material0 = new THREE.MeshBasicMaterial( {color: "red"});
			var yarn_material1 = new THREE.MeshBasicMaterial( {color: "black"});
			var yarn_material2 = new THREE.MeshBasicMaterial( {color: "green"});
			var yarn_material3 = new THREE.MeshBasicMaterial( {color: "blue"});
			hook_diam_mm = 11.5; //standard hook sizing is hook diameter in mm
			hook_r_inches = hook_diam_mm/(2*mm_per_inch); //converted to inches 
			var hook_r = inches_to_pixels(hook_r_inches);

			var x_max = window.innerWidth/4/2; //affects centering off piece
			var start_x = x_max;

			var start_y = 000;
			var start_z = 000;

			var xpos = start_x;
			var ypos = start_y;
			var zpos = start_z;
			var direction = 1; // implement this later

			// Smooth curve over this many points
			var numPoints = 100;
			var scene_add_geometries = []; //will add all at once later
			//to facillitate generation of multiple geometries in function calls

			// using "_" naming convention for all geometry funcs to 
			// differentiate custom functions and THREE.js builtins

			// Given a CatmullRomCurve3, creates a THREE.geometry  
			// that follows this curve, smoothed over n_points points.
			// Possible helper for all custom geometry functions.
			function path_geometry_from_curve(n_points, curve){
				new_geom = new THREE.Geometry();
				geom_points = curve.getPoints(n_points);

				for(var i = 0; i < n_points; i++){
				    new_geom.vertices.push(geom_points[i]);  
				}
				return new_geom;
			}

			// Makes a (starting) tail yarn end 
			// starting at (xpos, ypos, zpos)
			function tail_geometry(xpos, ypos, zpos){
				tail_length_inches = 2; 
				tail_length_pixels = inches_to_pixels(tail_length_inches); 

				tail_curve = new THREE.CatmullRomCurve3([
				   new THREE.Vector3(xpos, ypos, zpos),
				   new THREE.Vector3(xpos - (tail_length_pixels/2), ypos - (tail_length_pixels/5), zpos),
				   new THREE.Vector3(xpos - tail_length_pixels, ypos, zpos),
				]);
				tail_geom = new THREE.TubeGeometry(tail_curve, 64, pix_per_radius);

				scene_add_geometries.push(tail_geom)
				return tail_geom;
				//return geometry_from_curve(n_points, tail_curve);
			}

			function slip_geometry(start_x, start_y, start_z){
				//starts at xpos, ypos, zpos
				xpos = start_x;
				ypos = start_y;
				zpos = start_z;

				slip_array = [new THREE.Vector3(xpos, ypos, zpos)];
				yz0_end_theta = 2*Math.PI;
				//polar/spherical coordinates
				//ellipse with an innerheight of yarn radius and innerwidth of 2*yarn radius
				for (var t = 0; t <= yz0_end_theta; t = t + (Math.PI/32)){ 
					yz0_x = xpos + (t * 2 * pix_per_radius/(yz0_end_theta)); //+ slowly move toward xpos - radius
					//2 * radius is a diameter
					yz0_y = ypos - 2*pix_per_radius*Math.cos(t);
					//4 * radius is two diameters
					yz0_z = zpos - 4*pix_per_radius*Math.sin(t);
					
					slip_array.push(new THREE.Vector3(yz0_x, 
						yz0_y, yz0_z));

					console.log(t);
					console.log("end t is "+yz0_end_theta);
					if (t == yz0_end_theta){
						xpos = xpos + (2 * pix_per_radius);
						ypos = ypos - 2*pix_per_radius*Math.cos(yz0_end_theta);
						zpos = zpos - 4*pix_per_radius*Math.sin(yz0_end_theta);
					}
				}

				///
				connector_array = [
					//connect to end of hook_loop 
					new THREE.Vector3(xpos, ypos, zpos),
					new THREE.Vector3(xpos, ypos, zpos - (1* pix_per_radius)),
					new THREE.Vector3(xpos, ypos + (1 * pix_per_radius), zpos - (2* pix_per_radius)),
					new THREE.Vector3(xpos - (1* pix_per_radius), ypos + (2 * pix_per_radius), zpos - (2* pix_per_radius)),
					new THREE.Vector3(xpos - (2* pix_per_radius), ypos + (2 * pix_per_radius), zpos - (2* pix_per_radius)),
				];
				slip_array = slip_array.concat(connector_array);
				
				xpos = xpos - (2* pix_per_radius);
				ypos = ypos + (3 * pix_per_radius);
				zpos = zpos - (3* pix_per_radius);

				///
				loop_r = hook_r + pix_per_radius;
				loop_center_x = xpos - loop_r;
				loop_center_z = zpos + loop_r;
				loop_array = [];

				loop_start_theta = Math.atan(xpos/zpos);
				slip_array.push(
					new THREE.Vector3(loop_center_x + loop_r*Math.cos(loop_start_theta), ypos, 
						loop_center_z + loop_r*Math.sin(loop_start_theta)));

				loop_theta_d= Math.PI;//angular displacement
				//start loop at xpos, ypos, zpos
				//start where sint == cost, or t == pi/4
				for (var t = loop_start_theta; t <= loop_start_theta + loop_theta_d; t = t + (Math.PI/16)){ 
					loop_x = loop_center_x - loop_r*Math.cos(t);
					loop_z = loop_center_z + loop_r*Math.sin(t);

					loop_array.push(new THREE.Vector3(loop_x, ypos, loop_z));
					if (t == loop_start_theta + loop_theta_d){
						xpos = loop_x;
						zpos = loop_z;
					}
				}
				slip_array = slip_array.concat(loop_array);

				//finish slip
				slip_array.push(new THREE.Vector3(start_x, start_y, zpos - pix_per_radius));
				slip_array.push(new THREE.Vector3(start_x + 3*pix_per_radius, start_y, zpos - pix_per_radius));

				slip_curve = new THREE.CatmullRomCurve3(slip_array);
				slip_geom = new THREE.TubeGeometry(slip_curve, 64, pix_per_radius);
				scene_add_geometries.push(slip_geom);
				return slip_geom;
			}

			stitch_x_mag = { //magnitudes
				//all positive values, sign is denoted by the direction variable
				"tail": 10,
				"slip": 10
			};

			function draw_scene_geometries(scene_geometries, material){
				for(var sg = 0; sg < scene_geometries.length; sg++){
					scene.add(new THREE.Line(scene_geometries[sg], material));
				}
			}

			/// Testing specific function calls.
			// tail
			tail_geometry(start_x, start_y, start_z);
			xpos = xpos - tail_length_pixels;
			// slip stitch
			slip_geometry(xpos, ypos, zpos);
			draw_scene_geometries(scene_add_geometries, yarn_material0);

			function render() {
				var delta = clock.getDelta();
				requestAnimationFrame( render );
				cameraControls.update(delta);
				renderer.render( scene, camera );
			}
			render();

		</script>
	</body>
</html>
	
	